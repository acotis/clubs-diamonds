
——————————
North star ideas
——————————

Redundant expressions are the devil. It may seem okay to generate lots of
redundant expressions as long as you're faster at processing each expression
as a trade-off, but you CAN'T be faster at processing expressions because
YOU DON'T DECIDE HOW LONG IT TAKES TO EVALUATE AN EXPRESSION. The user's
code does. Generating an expression can be fast as lightning but if they're
taking a millisecond to judge it then it takes a millisecond to process.

Note: I have just modified Expression to read its instruction array forward
rather than backward. I did this even though testing suggests it might be 5%
slower, because I'm deciding that it's just too frustrating in general to try
to really detect these 5% speed differences under messy real-world operating
conditions, and a forward array is what makes sense to me. I should be spending
my time having big good ideas that affect runtime by 2x, not fucking around
with decisions I can barely observe the effects of.

You do want a separate test program; it allows you to do things like generate
color-coded reports showing performance changes. Also, #[test] code is a
little bit slower (like 2x) even when you use `cargo test --release`.

——————————
Todo
——————————

— Near-term:
    — Implement data-copy hotkey?

— More ideas from recent rewrite:
    — Try splitting out a MulWriter that uses a Children.
    — Prove that "liquifying" operators really are liquifying.
    — Write basic IO tests for parsed expressions.
    — In Expression::from_str(), make it a parse error for an expression
      to use variables beyond its arity.

— Testing:
    — Write correctness tests for the max-constant feature specifically.
    — Write correctness tests for finnicky usability features, like the
      ability to pass arbitrary closures (not just function pointers) as
      judges, inspectors, and penalizers.
    — Clean out empty and mostly-empty benchmarks.
        — Create a system for tracking important benchmark files.
    — Write benchmarks that specifically target expression application.
    — Write benchmarks that invoke the .max_constant() feature, specifically
      with low maximums (as this seems to slow Clubs down significantly).

— Publically maintaining:
    — Read, and try to comply with, Rust library guidelines.

— Features:
    — Add a feature to copy-to-clipboard whatever's in the inspector.
        — Or copy the expression itself.
    — Add var type and var count to the header of the Description panel.
    — Implement canaries (expressions given to the Searcher to try first,
      so that you can check that your predicate is correct).
    — Implement required_variables().
        — Benchmark the changes.
        — Add correctness tests and benchmark tests for this.
    — Implement max_to_find().
    — Implement max_to_search().
    — Implement max_score().
    — Implement timeout() maybe?
    — Implement an Expression::len() that doesn't go through format!()?

— Bugfixes:
    — Fix the problem where quitting the UI can cause threads to panic.
    — Fix the problem where (I think this is how it works) if the inspector
      or penalizer panics, worker threads panic too.
    — Fix "the problem where the UI takes over your terminal".
        — Not sure what I meant by this but I think I'm talking about how it
          can stay in screwed-up ratatui mode after Clubs is closed (maybe after
          it's force-quit?).
    — Clean up the threads when you return (just join on them I guess).
        — Is this not already happening?

— Performance:
    — Make the engine try not to render expressions unless it needs to.
        — Particularly, don't render every solution you find. One use-case of
          Clubs is to find all expressions of a given length, and then there
          are millions of solutions.
    — Try using u64's to count expressions instead of u128's, see if it's any
      faster (it might be, since we increment one every time we try a candidate
      expression, and u128's are not native on most machines).
    — Try the u128 implementation (again).
    — Try varying the stack size of Expression::apply().
    — Try varying the field size of find_with_length_and_op().
    — Try letting Expression::apply() use uninitialized memory as its stack.
    — Try varying the delay length between control thread cycles and the max
      value of the frame clock.
    — Try reversing the order of permutations so that they increase instead
      of decreasing (merely reversing the order in which children are traversed
      actually made Clubs slower, but I don't get why).

——————————
Ideas
——————————

— Idea for testing: create a TestUI type that implements the UI trait and whose
  behavior is to randomly fiddle with the controls during the test run.

— Make the "report every N expressions" thing automatically scale to a duration?
    — This would be good for cleaning up threads; if the worker thread only
      checks for signals from the manager thread every N expressions, and N is
      configured to be too high, then it could take a while before the thread
      sees that it's supposed to terminate. If it auto-scales, this mostly can't
      be an issue (actually it still could be, if some expressions take wildly
      longer to evaluate than others or some weird thing like that — maybe it
      should autoscale by default but there should still be a "report every N
      expressions" setting for if the user knows this will be an issue). Either
      way, there could maybe be a "report every N milliseconds" setting. Also,
      mind you that the worker threads do NOT need to coordinate with or wait
      for the manager thread to autoscale their report timings! They only time
      anyone waits for the manager thread is when a worker thread finishes its
      task.

