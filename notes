
——————————
UI revolution todo list
——————————

— Factor out a trait called UI.
— Create a trivial (null) implementor of the trait.
— Parameterize the .run() method over the UI trait and remove the bool argument.
— Add methods to the interface such that the UI can receive updates when a thread
  reports that it has rejected a batch of N candidates.
— Update the .run() method to invoke these methods.
— Extend the DefaultUI struct to compute and display the desired stats.
— Make the order of blocks be fixed as Description, Inspector, Stats, Threads,
  News.

——————————
Todo
——————————

— Stats:
    — Add expr/sec (per-thread avg).
    — Add expr/sec (current).
    — Add expr/sec (current per-thread).
    — Add expr/sec (max)?
    — Add expr/sec (max per-thread)?

— Generalize benchmarking infrastructure to accept arbitrary tasks.
— Write benchmarks that specifically target expression application.

— Make it work even in debug mode?

3. Add constant-limiting to the public API.
    — Benchmark the changes.
    — Add correctness tests and benchmark tests for this.
4. Add variable-requirement toggling to the public API.
    — Fix the bug where zero-variable expressions don't work.
    — Benchmark the changes.
    — Add correctness tests and benchmark tests for this.

— Try the u128 implementation.

— Implement pausing via the UI.
    — Make it so that decreasing the thread count pauses extra threads!

— Clean up the threads when you return (just join on them I guess).
— Implement max_to_find().
— Implement max_to_search().

— Fix the issue where you can't capture variables in closures you pass to 
  Searcher (maybe the type it takes should be "closure" (if that's possible) 
  instead of "fn"?).
— Implement Expression::parse(String).
    — Then, implement trial expressions where you can "seed" a search with
      some expressions to try first and treat as solutions, as a way of
      testing your inspector.

— Little improvments:
    — Benchmark variations to the max stack size of Expression::apply().
    — Benchmark variations to the field size of find_with_length_and_op().
      On 2025 Jun 04, lowering it from 99 to 20 genuinely seems to matter.
    — Add the option back of using a "scorer" (but still usize) instead of a penalizer.
    — Factor out a SearchUI::toggle_block().
    — Benchmark a 100us control cycle delay over 1ms; switch if faster.
    — In UI, make it only render the first 1000 solutions for speed.
    — Make the solution inspector always visible again.
        — Add a timestamp to each solution that is displayed in the inspector.

— In UI, make the solutions list scrollable.
— Make the "report every N expressions" thing automatically scale to a duration?
    — This would be good for cleaning up threads; if the worker thread only checks for
      signals from the manager thread every N expressions, and N is configured to be
      too high, then it could take a while before the thread sees that it's supposed
      to terminate. If it auto-scales, this mostly can't be an issue (actually it still
      could be, if some expressions take wildly longer to evaluate than others or some
      weird thing like that — maybe it should autoscale by default but there should
      still be a "report every N expressions" setting for if the user knows this will
      be an issue). Either way, there could maybe be a "report every N milliseconds"
      setting. Also, mind you that the worker threads do NOT need to coordinate with or
      wait for the manager thread to autoscale their report timings! They only time
      anyone waits for the manager thread is when a worker thread finishes its task.
— In UI, get rid of "initializing" state. It's misleading.
— Implement some kind of mechanism for blocking sub-expressions that are purely constants?
    — But mind you that some of these are good, like 1<<20.
