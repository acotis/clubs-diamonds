
——————————
North star idea
——————————

Redundant expressions are the devil. It may seem okay to generate lots of
redundant expressions as long as you're faster at processing each expression
as a trade-off, but you CAN'T be faster at processing expressions because
YOU DON'T DECIDE HOW LONG IT TAKES TO EVALUATE AN EXPRESSION. The user's
code does. Generating an expression can be fast as lightning but if they're
taking a millisecond to judge it then it takes a millisecond to process.

Note: I have just modified Expression to read its instruction array forward
rather than backward. I did this even though testing suggests it might be 5%
slower, because I'm deciding that it's just too frustrating in general to try
to really detect these 5% speed differences under messy real-world operating
conditions, and a forward array is what makes sense to me. I should be spending
my time having big good ideas that affect runtime by 2x, not fucking around
with decisions I can barely observe the effects of.

——————————
Ideation about new architecture.
——————————

Fundamentally, every expression can be decomposed into 1 or more components
which are being bitwise-or'd together. For example, 1+a|b|c*3 has three
components and 9-a has one (and so no syntactic bitwise-or operator). The
bitwise-or operator is the lowest-precedence operator that Clubs considers,
and it is commutative and associative. Therefore, the order of these compoents
does not affect the meaning of the expression. Therefore, when generating
expressions, we can stipulate that each component is "greater" (meaning,
further along in the search order) the the previous.

Furthermore, the bitwise-or operator does not care about multiple constants.
That is to say, if any two components of this group are both constants, then
the expression is a redundant copy of another shorter-or-equal expression in
which these two constants are unified into one (todo: prove this). Therefore,
we can also stipulate that only one component may be a constant.

Each component in this group can be further decomposed. The next decomposition
is into 1 or more components which are being bitwise-xor'd together. For
example, a*4^3<<b has two components, and 9+(5|a) has only one. Bitwise-xor
is also commutative and associative, and it also does not care about multiple
constants (todo: prove this), so the same optimizations may be made here.

The next decomposition is by bitwise-and; the same things are true here
(todo: prove this) so the same optimizations may be made.

The next level of precedence is the << and >> operators. These are highly
non-commutative and highly non-associative. They even do care about multiple
constants: the expression "a<<5>>5" is not equivalent to the expression "a"
because the top 5 bits can get chopped off. And, the expression "1<<20" is
itself a constant, but not one that can be expressed in any shorter expression.
So "1<<20" is not redundant either. On this level, I see no optimizations that
can be made.

The next level of precedence is the + and - operators. These are not quite
completely commutative (+ is but - isn't) or associative (+ is but - isn't)
but they have a simplifying property: any number of values added or subtracted
together according to any expression structure at all, is equivalent to a
single flattened expression structure in which first zero or more terms are
added to one another and then zero or more terms are subtracted from their sum.
For example, consider the expression (a+b)-(c-(d-e)): this is equivalent to
a+b+d-c-e. Furthermore, this level of precedence does not care about mutliple
constants: if, in this flattened structure, there are multiple constant terms,
they may be collected together into one without lengthening the expression
(todo: prove this). Finally, the order of the added terms is irrelevant, and
the order of the subtracted terms is irrelevant.

These properties of the level mean that we can perform similar optimizations
as we can for the other levels: we need only consider expressions which
comprise an "ascending" series of components to be added together followed by
an "ascending" series of components to be subtracted from them, with at most
one term among both sets being constant. The only caveat is that, if the
ascending series of added terms is *empty* (it has no terms) then the
expression needs a leading "0", because -a*b-3 groups as (-a)*b-3, not as
-(a*b)-3. (todo: check if this ever actually matters). When the expression
has a leading "0", this constitutes the one constant term which the process
is allotted, since any other constant could be merged into this one (todo:
prove or disprove this). So in fact, by this syntactic constraint, what is
really true is that there is always at least one added term (which may be
the allotted constant, or not) and zero or more subtracted terms. (todo:
double-check the reasoning/framing here)

The next precedence level is * / %. This level is the worst of all, because
one of its operations is commutative and associative and has rules about
constants (*), another has rules about constants (/ because a/10/4 = a/40,
todo: prove this), and the last has nothing (%). This is an inconvenient
juxtaposition of facts because it means that any optimizations we come up
with must be carefully designed to apply only to the operators which can
tolerate them, not to the level as a whole as we've done above.

Let's first say some properties that this level does not have. For one
thing, * and / do not share constants the way we might want them to. The
expression a*3/4 is not redundant with anything because the value 3/4
(three-fourths) is not available as a consant; in fact, the expression
a*6/3 isn't even redundant with anything due to the possibility of
overflow (and this applies even to signed types). Furthermore, even in
a sequence of just * and / and constants, order matters: a*3/4 is not
redundant with a/4*3 (try plugging in a=2).

Here are some things that are true. One, * itself is commutative and
associative and consant-merging (todo: prove this). Two, % is constant-
merging. Three, I'm pretty sure / has its own kind of constant-merging
where a/C1/C2 is redundant with a/C3 where C3=C1*C2, but I'm really not
sure about that (todo: investigate this).

Now begins the wild ideation segment of this writeup. Well, the structure
of this level is always ((((A op B) op C) op D) op E), or so (I'm saying
that all these operations are left-associative). So what exactly might
an optimization look like?

We know that % is constant-merging. What does that rule out? It rules out
only that the left and right sides of a % operator should both be constant.
Okay, so if the innermost parenthetical is (A % B) with A and B both being
constants, then that's ruled out. The same is ruled out for the * and /
operators. But only when it's A and B! Because look: let's say we're
talking about ((A op B) op C) and trying to apply the optimization that
that second "op" there is constant-merging. Well, the only way the
left-hand side could be a constant is if A and B are both constants, and we
just said that shouldn't be the case. So I guess maybe we get a principle
popping out of this that's like: "On the * / % level, the first two terms
cannot both be constant".

Here's a toughie: the expression a/(a%3) cannot be simplified.

Also: a*3*5 can be simplified.

Actually, it's a big deal that a/(a%3) can't be simplified. That means
that the structure of "this level" (by which I guess I mean...

Well, actually, what it really means is that non-redundant expressions have
a different structure at this level than they do at other levels, and the
very concept of a "level" must be ammended to reflect this. Further
research is needed.

Random observation: if we can only reach expressions of length ~15 or so
anyway, then we don't need to worry too much about expressions that have
tons and tons of stuff in them.

The last level of structure is the unary level: ! and -. These two
operators both have the property that applying them twice is a no-op:
!!a = --a = a. Therefore, we need only consider sequences of alternating
! and - operators. Such a sequence is defined unambiguously by its length
and innermost operator.



——————————
Todo
——————————

— Rewrite attempt:
    — INTERMISSION: do full AB test vs previous arch.
    — Rename Searcher::var_names() to Searcher::revar().
    — Update all documentation.
    — Change demo-2 example to not be solveable with one variable.
    — Try iterating through Children sets backwards.
    — Try splitting out a MulWriter that uses a Children.
    — Prove that "liquifying" operators really are liquifying.
    — Write basic IO tests for parsed expressions.

— Testing:
    — Guiding thought: you do want a separate test program; it allows you to
      do things like generate color-coded reports showing performance changes.
      Also, #[test] code is a little bit slower (like 2x) even when you use
      `cargo test --release`.
    — Write correctness tests for the max-constant feature specifically.
    — Write correctness tests for finnicky usability features, like the
      ability to pass arbitrary closures (not just function pointers) as
      judges, inspectors, and penalizers.
    — Work on the benchmark binary search project (below).
    — Add a way to compare two benchmark reports to each other.
    — Clean out empty and mostly-empty benchmarks.
    — Generalize benchmarking infrastructure to accept arbitrary tasks.
    — Write benchmarks that specifically target expression application.
    — Write benchmarks that invoke the .max_constant() feature, specifically
      with low maximums (as this seems to slow Clubs down significantly).

— Publically maintaining:
    — Read, and try to comply with, Rust library guidelines.

— Features:
    — Make unary arithmetic negation optionally included.
    — Implement required_variables().
        — Benchmark the changes.
        — Add correctness tests and benchmark tests for this.
    — In UI, make the solutions list scrollable.
    — Implement Expression::parse(String).
    — Implement max_to_find().
    — Implement max_to_search().
    — Implement timeout() maybe?
    — Implement scorer() as distinct from penalizer().
    — Implement an Expression::len() that doesn't go through format!()?

— Bugfixes:
    — Fix the problem where quitting the UI can cause threads to panic.
    — Fix "the problem where the UI takes over your terminal".
        — Not sure what I meant by this but I think I'm talking about how it
          can stay in screwed-up ratatui mode after Clubs is closed (maybe after
          it's force-quit?).
    — Fix the bug where zero-variable expressions don't work.
    — Clean up the threads when you return (just join on them I guess).
        — Is this not already happening?
    — In UI, make it only render the solutions which will fit on the screen.
    — Fix the issue where you can't capture variables in closures you pass to 
      Searcher (maybe the type it takes should be "closure" (if that's possible) 
      instead of "fn"?).

— Performance:
    — Make the engine try not to render expressions unless it needs to.
        — Particularly, don't render every solution you find. One use-case of
          Clubs is to find all expressions of a given length, and then there
          are millions of solutions.
    — Try using u64's to count expressions instead of u128's, see if it's any
      faster (it might be, since we increment one every time we try a candidate
      expression, and u128's are not native on most machines).
    — Try the u128 implementation (again).
    — Try varying the stack size of Expression::apply().
    — Try varying the field size of find_with_length_and_op().
    — Try letting Expression::apply() use uninitialized memory as its stack.
    — Try varying the delay length between control thread cycles and the max
      value of the frame clock.

——————————
Ideas
——————————

— Idea for testing: create a TestUI type that implements the UI trait and whose
  behavior is to randomly fiddle with the controls during the test run.

— Make the "report every N expressions" thing automatically scale to a duration?
    — This would be good for cleaning up threads; if the worker thread only
      checks for signals from the manager thread every N expressions, and N is
      configured to be too high, then it could take a while before the thread
      sees that it's supposed to terminate. If it auto-scales, this mostly can't
      be an issue (actually it still could be, if some expressions take wildly
      longer to evaluate than others or some weird thing like that — maybe it
      should autoscale by default but there should still be a "report every N
      expressions" setting for if the user knows this will be an issue). Either
      way, there could maybe be a "report every N milliseconds" setting. Also,
      mind you that the worker threads do NOT need to coordinate with or wait
      for the manager thread to autoscale their report timings! They only time
      anyone waits for the manager thread is when a worker thread finishes its
      task.

— Implement some kind of mechanism for blocking sub-expressions that are
  purely constants? But mind you that some of these are good, like 1<<20.

——————————
Binary search for the slowdown
——————————

Hypothesis: bluetooth being connected could matter?

22efc3f Changed capitalization in title of threads panel.
985adef Re-chose colors such that they look good in other terminals too.
23017b1 Fixed compiler warnings.
0df86f5 Moved utils module back into the UI module where it belongs.
23b6c6c Moved expression-count news-item formatting into the UI.
8431da8 Updated notes.
cf431c8 Moved test code out to a separate project.
c59aa26 Improved documentation.
93840dd Improved documentation.
c06d8df Improved documentation.
30acc54 Updated demo to use 3 threads because it looks better that way in a screenshot.
73e2871 Fixed a bug where selecting a very long solution can cause the UI to crash.
3c19a12 Moved solution spotlight into the header of the solution inspector.
46b5a2c Made the order of blocks be fixed as description, inspector, stats, threads, news.
75fd937 Updated notes.
bca3297 Fixed benchmark timestamp formatting.
cb04983 Updated notes.
049743f Made 'add an inspector with Searcher::inspector()' the highest-priority error case of the Solution Inspector.
4a66cfe Made the 'missing value' style darker.
2365541 Improving 'no inspection/description provided' help texts.
36a8968 Removed debug stuff and updated notes file.
08565fe Got new stats working.
29831eb Working on implementing StatMoments as a way of tracking per-thread stats.
b51fe55 Reordered the UI-rendering methods of DefaultUIFace.
e5ac278 Moved Thread and ThreadStatus to the UI interface file.
b3e7851 Parameterized .run() over different UI types.
d4a12f6 Created NullUI struct.
e6c0d97 Moved DefaultUI's implementation to its own file.
97b13a0 Factored out a UI trait.
67529aa Minor signature refactors.
4a018c9 Drafted UI trait.
d63ca99 Made the solution inspector always 'enabled' (in the sense of being available in the UI at all) and renamed SearchUI to DefaultUI.
babc4b2 Improved documentation.
8f35116 Updated notes.
ce8b49b Updated notes.
ec32a38 Improved documentation.
e7b78eb Updated todo.
231726a Updated todo.
d20e6d7 Bumped version.
b49197c Updated notes.
1df4fe9 Changed format of benchmark timestamps.
c5754ae Added usage note about compiling in release mode and using LTO optimizations.
2781048 Fixed typo.
b91ce7a Bumped version.
3160bb6 Added documentation for Number trait and its methods.
2efba82 Bumped version.
7f1e8d7 Fixed some documentation problems.
b7c8333 Bumped version.
856a3fb Updated todo.
373c1ab Updated demo images.
3ac82ae Minor changes.
22e6cf5 Finalizing demos.
cf1cfa2 Documented Number trait.
6578f38 Added notes.
8708e77 Fix compiler warnings and update variable names.
31846ca Created test bins.
e624841 Updated docs.
532ccb0 Bumped version.
a79d2a7 Updated documentation.
289fef2 Updated documentation.
dbd0194 Working on documentation.
2272c7c Hid nitty-gritty details of Expression struct.
36c2fda Added a layer of module structure back in privately, just so that I can get the visibility right on Expression's fields.
0b28fde Removed some unused methods from Expression.
acb66bc Added documentation to Expression.
4713dda Documented the Searcher type.
26cd9d6 Working on documentation.
221d95c Fixed compiler warnings.
11232b7 Working on documentation.
897f685 Updating documentation.
23ed04c Supposedly removed the concept of the ExpressionCore.
    — 2025 Nov 6:
        — Atrociously bad performance (+20% on some long ones).
        — Suspicious circumstances:
            — CPU usage was very low and bouncing around when I looked.
            — Laptop had been on for 11 days consecutively when I ran this.
    — 2025 Nov 7:
        — Better. Didn't run to completion or check times carefully.
80bbae1 Updated todo items.
1c783be Made Number trait public (so users can write functions that use it in trait bounds, for example).
d998f7d Moved demo.rs to a new bin/ directory.
9cd7bb8 Removed two layers of module nesting so that the main types this library provides are now available at the crate root.
67fb653 Made utils mod non-public.
4f74cda Working on documentation.
2dab11d Updated documentation.
2b4a3c3 Working on documentation.
0822bbe Minor updates to documentation.
a38de5f Began work on documentation.
9587161 Updated Cargo.toml.
cb2725a Added metadata for publishing.
3001ced Added base implementation of the clubs engine.
ce22c9c Initial commit
